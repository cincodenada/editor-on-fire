#include <allegro.h>
#include "main.h"
#include "note.h"
#include "export.h"

static EOF_MIDI_EVENT eof_midi_event[EOF_MAX_MIDI_EVENTS];
static int eof_midi_events;

void WriteVarLen(unsigned long value, PACKFILE * fp)
{
	unsigned long buffer;
	buffer = value & 0x7F;

	while((value >>= 7))
	{
		buffer <<= 8;
		buffer |= ((value & 0x7F) | 0x80);
	}

	while(1)
	{
		pack_putc(buffer, fp);
		printf("%d - %d\n", value, buffer);
		if(buffer & 0x80)
		{
			buffer >>= 8;
		}
		else
		{
			break;
		}
   }
}

unsigned long ReadVarLen(PACKFILE * fp)
{
	unsigned long value;
	unsigned char c;

	if((value = pack_getc(fp)) & 0x80)
	{
		value &= 0x7F;
		do
		{
			value = (value << 7) + ((c = pack_getc(fp)) & 0x7F);
		} while (c & 0x80);
	}

	return value;
}

int qsort_helper(const void * e1, const void * e2)
{
    EOF_NOTE * thing1 = (EOF_NOTE *)e1;
    EOF_NOTE * thing2 = (EOF_NOTE *)e2;

    if(thing1->pos < thing2->pos)
	{
        return -1;
    }
    if(thing1->pos > thing2->pos)
    {
        return 1;
    }

    // they are equal...
    return 0;
}

int qsort_helper2(const void * e1, const void * e2)
{
    EOF_NOTE * thing1 = (EOF_NOTE *)e1;
    EOF_NOTE * thing2 = (EOF_NOTE *)e2;

    if(thing1->active && !thing2->active)
	{
        return 1;
    }
    if(!thing1->active && thing2->active)
    {
        return -1;
    }

    // they are equal...
    return 0;
}

void eof_sort_notes(void)
{
    qsort(eof_song.track[eof_selected_track].note, EOF_MAX_NOTES, sizeof(EOF_NOTE), qsort_helper2);
    qsort(eof_song.track[eof_selected_track].note, EOF_MAX_NOTES, sizeof(EOF_NOTE), qsort_helper);
}

/* write MTrk data to a temp file so we can calculate the length in bytes of the track
   write MThd data and copy MTrk data from the temp file using the size of the temp file as the track length
   delete the temp file
   voila, correctly formatted MIDI file */
int eof_export_midi(char * fn)
{
	char header[14] = {'M', 'T', 'h', 'd', 0, 0, 0, 6, 0, 0, 0, 1, 0xE7, 0x28}; // timing based in milliseconds
	char trackheader[8] = {'M', 'T', 'r', 'k', 0, 0, 0, 0};
	PACKFILE * fp;
	PACKFILE * fp2;
	int i;
	unsigned long curr_pos = 0;
	unsigned long last_pos = 0;
	unsigned long last_length = 0;
	unsigned long delta = 0;
	unsigned long track_length;
	char triggered = 0;
	int midi_note_offset;
	
	/* clear MIDI events list */
	memset(eof_midi_event, 0, sizeof(EOF_MIDI_EVENT) * EOF_MAX_MIDI_EVENTS);
	eof_midi_events = 0;
	
	/* open the file */
	fp = pack_fopen("eof.tmp", "w");
	if(!fp)
	{
		return 0;
	}
	
	/* sort notes so they are in order of position */
	eof_sort_notes();

	/* write tempo data */
	WriteVarLen(0, fp);
	pack_putc(0xff, fp);
	pack_putc(0x51, fp);
	pack_putc(0x03, fp);
//	pack_putc(0x0F, fp);
//	pack_putc(0x42, fp);
//	pack_putc(0x40, fp);
	pack_putc(0x07, fp);
	pack_putc(0xA7, fp);
	pack_putc(0x10, fp);
	
	/* write the MTrk MIDI data to a temp file
	   use size of the file as the MTrk header length */
	for(i = 0; i < EOF_MAX_NOTES; i++)
	{
		if(eof_song.track[eof_selected_track].note[i].active)
		{
			switch(eof_song.track[eof_selected_track].note[i].type)
			{
				case EOF_NOTE_AMAZING:
				{
					midi_note_offset = 0x60;
					break;
				}
				case EOF_NOTE_MEDIUM:
				{
					midi_note_offset = 0x54;
					break;
				}
				case EOF_NOTE_EASY:
				{
					midi_note_offset = 0x48;
					break;
				}
				case EOF_NOTE_SUPAEASY:
				{
					midi_note_offset = 0x3C;
					break;
				}
			}
			triggered = 0; // reset trigger so we know where to put 0 deltas
			delta = (eof_song.track[eof_selected_track].note[i].pos - last_pos) * 118;
			printf("%ul\n", delta);
			last_pos = eof_song.track[eof_selected_track].note[i].pos;
			
			/* write green note */
			if(eof_song.track[eof_selected_track].note[i].note & 1)
			{
				if(!triggered)
				{
					WriteVarLen(delta, fp);
					triggered = 1;
				}
				else
				{
					WriteVarLen(0, fp);
				}
				pack_putc(0x90, fp);
				pack_putc(midi_note_offset + 0, fp);
				pack_putc(0x64, fp);
			}
			
			/* write yellow note */
			if(eof_song.track[eof_selected_track].note[i].note & 2)
			{
				if(!triggered)
				{
					WriteVarLen(delta, fp);
					triggered = 1;
				}
				else
				{
					WriteVarLen(0, fp);
				}
				pack_putc(0x90, fp);
				pack_putc(midi_note_offset + 1, fp);
				pack_putc(0x64, fp);
			}
			
			/* write red note */
			if(eof_song.track[eof_selected_track].note[i].note & 4)
			{
				if(!triggered)
				{
					WriteVarLen(delta, fp);
					triggered = 1;
				}
				else
				{
					WriteVarLen(0, fp);
				}
				pack_putc(0x90, fp);
				pack_putc(midi_note_offset + 2, fp);
				pack_putc(0x64, fp);
			}
			
			/* write blue note */
			if(eof_song.track[eof_selected_track].note[i].note & 8)
			{
				if(!triggered)
				{
					WriteVarLen(delta, fp);
					triggered = 1;
				}
				else
				{
					WriteVarLen(0, fp);
				}
				pack_putc(0x90, fp);
				pack_putc(midi_note_offset + 3, fp);
				pack_putc(0x64, fp);
			}
			
			/* write purple note */
			if(eof_song.track[eof_selected_track].note[i].note & 16)
			{
				if(!triggered)
				{
					WriteVarLen(delta, fp);
					triggered = 1;
				}
				else
				{
					WriteVarLen(0, fp);
				}
				pack_putc(0x90, fp);
				pack_putc(midi_note_offset + 4, fp);
				pack_putc(0x64, fp);
			}
			
			// reset trigger so we know where to put 0 deltas
			delta = eof_song.track[eof_selected_track].note[i].length * 118;
			last_pos += eof_song.track[eof_selected_track].note[i].length;
			triggered = 0;
			
			/* write green note off */
			if(eof_song.track[eof_selected_track].note[i].note & 1)
			{
				if(!triggered)
				{
					WriteVarLen(delta, fp);
					triggered = 1;
				}
				else
				{
					WriteVarLen(0, fp);
				}
				pack_putc(0x80, fp);
				pack_putc(midi_note_offset + 0, fp);
				pack_putc(0x40, fp);
			}
			
			/* write yellow note off */
			if(eof_song.track[eof_selected_track].note[i].note & 2)
			{
				if(!triggered)
				{
					WriteVarLen(delta, fp);
					triggered = 1;
				}
				else
				{
					WriteVarLen(0, fp);
				}
				pack_putc(0x80, fp);
				pack_putc(midi_note_offset + 1, fp);
				pack_putc(0x40, fp);
			}
			
			/* write red note off */
			if(eof_song.track[eof_selected_track].note[i].note & 4)
			{
				if(!triggered)
				{
					WriteVarLen(delta, fp);
					triggered = 1;
				}
				else
				{
					WriteVarLen(0, fp);
				}
				pack_putc(0x80, fp);
				pack_putc(midi_note_offset + 2, fp);
				pack_putc(0x40, fp);
			}
			
			/* write blue note off */
			if(eof_song.track[eof_selected_track].note[i].note & 8)
			{
				if(!triggered)
				{
					WriteVarLen(delta, fp);
					triggered = 1;
				}
				else
				{
					WriteVarLen(0, fp);
				}
				pack_putc(0x80, fp);
				pack_putc(midi_note_offset + 3, fp);
				pack_putc(0x40, fp);
			}
			
			/* write purple note off */
			if(eof_song.track[eof_selected_track].note[i].note & 16)
			{
				if(!triggered)
				{
					WriteVarLen(delta, fp);
					triggered = 1;
				}
				else
				{
					WriteVarLen(0, fp);
				}
				pack_putc(0x80, fp);
				pack_putc(midi_note_offset + 4, fp);
				pack_putc(0x40, fp);
			}
		}
	}
	pack_putc(0xFF, fp);
	pack_putc(0x2F, fp);
	pack_putc(0x00, fp);
	pack_fclose(fp);
	track_length = file_size_ex("eof.tmp");
	
	fp = pack_fopen(fn, "w");
	if(!fp)
	{
		return 0;
	}
	fp2 = pack_fopen("eof.tmp", "r");
	if(!fp2)
	{
		pack_fclose(fp);
		return 0;
	}
	
	/* write header data */
	pack_fwrite(header, 14, fp);
	pack_fwrite(trackheader, 4, fp);
	pack_mputl(track_length - 3, fp);
	
	for(i = 0; i < track_length; i++)
	{
		pack_putc(pack_getc(fp2), fp);
	}
	pack_fclose(fp);
	pack_fclose(fp2);
			
	return 1;
}

int eof_save_notes(char * fn)
{
	PACKFILE * fp;
	int i, j;
	char header[16] = {'E', 'O', 'F', 'S', 'O', 'N', 'G', 0};
	
	fp = pack_fopen(fn, "w");
	if(!fp)
	{
		return 0;
	}
	
	pack_fwrite(header, 16, fp);
	pack_fwrite(eof_song.artist, 256, fp);
	pack_fwrite(eof_song.title, 256, fp);
	
	for(i = 0; i < EOF_MAX_TRACKS; i++)
	{
		pack_putc(eof_song.track[i].active, fp);
		if(eof_song.track[i].active)
		{
			pack_fwrite(eof_song.track[i].name, 256, fp);
			for(j = 0; j < EOF_MAX_NOTES; j++)
			{
				pack_putc(eof_song.track[i].note[j].active, fp);
				if(eof_song.track[i].note[j].active)
				{
					pack_putc(eof_song.track[i].note[j].type, fp);
					pack_putc(eof_song.track[i].note[j].note, fp);
					pack_iputl(eof_song.track[i].note[j].pos, fp);
					pack_iputw(eof_song.track[i].note[j].length, fp);
					pack_putc(eof_song.track[i].note[j].flags, fp);
				}
			}
		}
	}
	pack_fclose(fp);
	return 1;
}

int eof_load_notes(char * fn)
{
	PACKFILE * fp;
	char header[16] = {'E', 'O', 'F', 'S', 'O', 'N', 'G', 0};
	char rheader[16];
	int i, j;
	int a;
	
	fp = pack_fopen(fn, "r");
	if(!fp)
	{
		return 0;
	}
	pack_fread(rheader, 16, fp);
	if(stricmp(rheader, header))
	{
		pack_fclose(fp);
		return 0;
	}
	pack_fread(eof_song.artist, 256, fp);
	pack_fread(eof_song.title, 256, fp);
	for(i = 0; i < EOF_MAX_TRACKS; i++)
	{
		a = pack_getc(fp);
		if(a)
		{
			eof_song.track[i].active = 1;
			pack_fread(eof_song.track[i].name, 256, fp);
			for(j = 0; j < EOF_MAX_NOTES; j++)
			{
				eof_song.track[i].note[j].active = 0;
				a = pack_getc(fp);
				if(a)
				{
					eof_song.track[i].note[j].active = 1;
					eof_song.track[i].note[j].type = pack_getc(fp);
					eof_song.track[i].note[j].note = pack_getc(fp);
					eof_song.track[i].note[j].pos = pack_igetl(fp);
					eof_song.track[i].note[j].length = pack_igetw(fp);
					eof_song.track[i].note[j].flags = pack_getc(fp);
				}
			}
		}
	}
	pack_fclose(fp);
	return 1;
}
